function [S, L, T, GIC, subLoc, nLines, nSubs, nTrans] = calc_gic_main(app, S, L, T, ex, ey, latq, lonq, tind, uniform, OriginalL, OriginalT)
% =======================================================================
% CALC_GIC_MAIN
% Computes GIC for edited and original networks
% Skips edited GIC if network hasn't changed
% =======================================================================

subLoc = reshape([S(:).Loc], 2, length(S))';
nLines = length(L);
nSubs = length(S);
nTrans = length(T);

% Enter when any of the original caches are missing OR empty
needOriginal = ...
    ~isprop(app,'gic_originalS') || isempty(app.gic_originalS) || ...
    ~isprop(app,'gic_originalL') || isempty(app.gic_originalL) || ...
    ~isprop(app,'gic_originalT') || isempty(app.gic_originalT);


% === Voltage Calculation ===
app.StatusTextArea.Value = [app.StatusTextArea.Value; '************************LINE VOLTAGES****************************'];
drawnow;
tic
if ~uniform
    V_original = calc_line_voltage(OriginalL, latq, lonq, ex(tind,:), ey(tind,:), 'natural');
    editedChanged = isNetworkChanged(L, T, OriginalL, OriginalT);
    if editedChanged
        V = calc_line_voltage(L, latq, lonq, ex(tind,:), ey(tind,:), 'natural');
    else
        V = [];
    end
    nTimes = size(V_original, 1);
else
    nTimes = 1;
end

app.StatusTextArea.Value = [app.StatusTextArea.Value; '********************LINE VOLTAGES:COMPLETED************************'];
drawnow;

% === Network Setup ===
app.StatusTextArea.Value = [app.StatusTextArea.Value; '********************NETWORK TOPOLOGY************************'];
drawnow;

[nodePairs0, nodeRes0, ~, edges0, indices0, neutralNodes0, autoind0, nBus0] = get_nodePairs(OriginalL, OriginalT, S);
[Yn0, Ye0] = calc_admittance_matrices(edges0, indices0, nodeRes0, neutralNodes0, S, nBus0);
indnull0 = find(diag(Yn0) == 0);
indnotnull0 = find(diag(Yn0) ~= 0);

if editedChanged
    [nodePairs, nodeRes, ~, edges, indices, neutralNodes, autoind, nBus] = get_nodePairs(L, T, S);
    [Yn, Ye] = calc_admittance_matrices(edges, indices, nodeRes, neutralNodes, S, nBus);
    indnull = find(diag(Yn) == 0);
    indnotnull = find(diag(Yn) ~= 0);
end

% === Initialize GIC Containers ===
app.StatusTextArea.Value = [app.StatusTextArea.Value; '***********************CALCULATING GIC*************************'];
drawnow;

GIC_Subs = NaN(nSubs, nTimes);
GIC_Lines = NaN(nLines, nTimes);
GIC_Trans = NaN(nTrans, 2, nTimes);

original_GIC_Subs = zeros(nSubs, nTimes);
original_GIC_Lines = zeros(length(OriginalL), nTimes);
original_GIC_Trans = zeros(length(OriginalT), 2, nTimes);

% === Progress milestones ===
milestones = [10, 25, 50, 70, 100];
loggedPercents = false(size(milestones));

% === Run GIC Calculation Loop ===
for i = 1:nTimes
    % --- Original GIC ---
    if needOriginal
        [original_GIC_Subs(:, i), original_GIC_Lines(:, i), original_GIC_Trans(:,:, i)] = ...
            calc_gic(OriginalL, OriginalT, V_original(i,:), Yn0, Ye0, nodePairs0, nodeRes0, autoind0, indices0, edges0, indnull0, indnotnull0, nBus0);
    else
        original_GIC_Subs(:, i) = app.gic_originalS(:,i);
        original_GIC_Lines(:, i) = app.gic_originalL(:,i);
        original_GIC_Trans(:,:, i) = app.gic_originalT(:,:,i);
    end

    % --- Edited GIC (if network changed) ---
    if editedChanged
        [GIC_Subs(:, i), GIC_Lines(:, i), GIC_Trans(:,:, i)] = ...
            calc_gic(L, T, V(i,:), Yn, Ye, nodePairs, nodeRes, autoind, indices, edges, indnull, indnotnull, nBus);
    
    else
        GIC_Subs(:, i) = NaN;
        GIC_Lines(:, i) = NaN;
        GIC_Trans(:,:, i) = NaN;
    end

    % --- Progress Indicator ---
    percentDone = round(100 * i / nTimes);
    for m = 1:length(milestones)
        if ~loggedPercents(m) && percentDone >= milestones(m)
            msg = sprintf('...%d%% complete', milestones(m));
            disp(msg);
            app.StatusTextArea.Value = [app.StatusTextArea.Value; msg];
            drawnow;
            loggedPercents(m) = true;
        end
    end
end
toc
elapsedTime = toc; % Get the elapsed time from the previous tic
app.StatusTextArea.Value = [app.StatusTextArea.Value; sprintf('Elapsed time: %.2f seconds', elapsedTime)];
drawnow;

% === Assign GICs to Network ===
[maxSub, ~] = max(abs(GIC_Subs), [], 2);
for i = 1:nLines
    L(i).GIC = GIC_Lines(i,:);
end
for i = 1:nSubs
    S(i).GIC = GIC_Subs(i,:);
    S(i).maxGIC = maxSub(i);
end

maxSub0 = max(abs(original_GIC_Subs), [], 2);
for i = 1:length(OriginalL)
    OriginalL(i).GIC = original_GIC_Lines(i,:);
end
for i = 1:nSubs
    S(i).GIC_Original = original_GIC_Subs(i,:);
    S(i).maxGIC_Original = maxSub0(i);
end


% === Package into Struct ===
GIC = struct();
GIC.Subs = GIC_Subs;
GIC.Lines = GIC_Lines;
GIC.Trans = GIC_Trans;
GIC.Original_Subs = original_GIC_Subs;
GIC.Original_Lines = original_GIC_Lines;
GIC.Original_Trans = original_GIC_Trans;


app.StatusTextArea.Value = [app.StatusTextArea.Value; '*******************COMPLETED: GIC***************************'];
drawnow;

fprintf(['Node #1       tap       Series (W1)       Node #2\n' ...
         'LV bus o------------.--------{}{}{}{}{}--------o HV bus\n' ...
         '                    |\n' ...
         '                    {}\n' ...
         '                    {}\n' ...
         '                    {}  Common (W2)\n' ...
         '                    {}\n' ...
         '                    |\n' ...
         '                    |               ___\n' ...           
         '          Node #3   o--------------- _   Ground point\n' ...
         '                                     . \n\n\n']);
end

function changed = isNetworkChanged(L, T, L0, T0)
    changed = ...
        ~isequal(extractNetwork(L), extractNetwork(L0)) || ...
        ~isequal(extractNetwork(T), extractNetwork(T0));
end

function out = extractNetwork(structArray)
    out = rmfield(structArray, intersect(fieldnames(structArray), {'GIC', 'maxGIC', 'GIC_Original', 'maxGIC_Original'}));
end
