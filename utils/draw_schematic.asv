function h = draw_schematic(b, mode, subName, ax, L, T, GIC, specTime)
%DRAW_SCHEMATIC  One-page substation view: lines in/out, xfmrs, and ground flow.
% Sign rule used here (your rule): for wye/auto windings, +GIC => to ground.
%
% Inputs:
%   subName  : substation name to plot
%   ax       : target axes / UIAxes
%   L        : line struct array with .Name .fromSub .toSub (case-insensitive)
%   T        : transformer struct array with .Name .Sub .HV_Type .LV_Type
%   GIC      : struct with GIC.Lines (nL x nT), GIC.Trans (nTxf x 2 x nT) [W1,W2]
%   timeIndex: time step index
%
% Output:
%   h        : handles (lines/text), optional for custom tweaks

    if nargin < 7, error('Need subName, ax, L, T, GIC, timeIndex'); end

    
                % === GIC Bubble Mode Selector ===
    switch mode
        case 'Display schematic at max'
            [~, idxMax] = max(abs(GIC.Subs), [], 2);
            gicVals = arrayfun(@(i) GIC.Subs(i, idxMax(i)), 1:size(GIC.Subs,1))';
            cVals = gicVals;
            titleStr = 'Max GIC Magnitude (All Time)';
            


        case 'Display schematic at chosen time'
            timeIndex = specTime;

    end
    
    
    
    
    % Canvas
    cla(ax); hold(ax,'on'); axis(ax,[0 10 0 10]); axis(ax,'off'); daspect(ax,[1 1 1]);    
    
    % Time label
    timeLbl = sprintf('Time: %s', datestr(b(1).times(timeIndex), 'yyyy-mmm-dd HH:MM:SS'));
    title(ax, sprintf('GIC Schematic — %s\n%s', subName, timeLbl), 'FontWeight','bold');

    % Center bus
    plot(ax,[4.2 5.8],[6.5 6.5],'k-','LineWidth',3);
    text(ax,5,7.05,subName,'HorizontalAlignment','center','FontWeight','bold');

    % Colors
    cLine = [0 0.45 0.85];   % lines
    cXfr  = [0.85 0.33 0.10];% transformers
    cGrnd = [0.15 0.55 0.15];% ground

    % ========= Lines: split into incoming (left) and outgoing (right) =========
    yTop = 9.2; dy = 1.05;
    yL  = yTop; yR = yTop;

    inSum  = 0;   % signed toward node (+)
    outSum = 0;   % signed away  from node (-)

    for i = 1:numel(L)
        if ~isfield(L(i),'fromSub') || ~isfield(L(i),'toSub'), continue; end
        isFrom = strcmpi(L(i).fromSub, subName);
        isTo   = strcmpi(L(i).toSub,   subName);
        if ~(isFrom || isTo), continue; end

        I = NaN;
        if isfield(GIC,'Lines') && size(GIC.Lines,1) >= i && size(GIC.Lines,2) >= timeIndex
            I = GIC.Lines(i,timeIndex);  % + means fromSub -> toSub
        end

        if isTo % at the "to" end, + means INCOMING to this node
            y = yL; yL = yL - dy;
            plot(ax,[1 4.2],[y y],'Color',cLine,'LineWidth',2);
            draw_arrow(ax, 3.6, y, 4.2, y, cLine);    % toward node
            text(ax, 1.1, y+0.25, sprintf('%s\n%.1f A', safeName(L(i)), I), ...
                 'Color',cLine,'FontSize',9,'HorizontalAlignment','left');
            inSum = inSum + I;  % toward node
        else % isFrom; + means OUTGOING from this node
            y = yR; yR = yR - dy;
            plot(ax,[5.8 9],[y y],'Color',cLine,'LineWidth',2);
            draw_arrow(ax, 5.8, y, 6.4, y, cLine);    % away from node
            text(ax, 8.9, y+0.25, sprintf('%.1f A\n%s', I, safeName(L(i))), ...
                 'Color',cLine,'FontSize',9,'HorizontalAlignment','right');
            outSum = outSum - I; % away from node (negative toward-node sum)
        end
    end

    if yL < yTop, plot(ax,[4.2 4.2],[yL 6.5],'k:'); end
    if yR < yTop, plot(ax,[5.8 5.8],[yR 6.5],'k:'); end

    % ===================== Transformers & ground per xfmr =====================
    tHere = find(strcmpi({T.Sub}, subName));
    yX = 4.75;
    subGroundSum = 0;   % sum of grounded-winding currents (signed; + to ground)

    if isempty(tHere)
        text(ax,5, yX, 'No transformers found','HorizontalAlignment','center');
    else
        for kk = 1:numel(tHere)
            ti = tHere(kk);
            % W1/W2 GIC at timeIndex (robustly)
            Iw1 = getG(GIC, ti, 1, timeIndex);
            Iw2 = getG(GIC, ti, 2, timeIndex);

            % Draw transformer
            draw_transformer_symbol(ax, 4.8, yX, cXfr);
            plot(ax,[4.8 5.0],[yX+0.60 6.5],'Color',[0.35 0.35 0.35]); % lead to bus

            % Labels
            conn = sprintf('%s/%s', lowerOrQ(T(ti),'HV_Type'), lowerOrQ(T(ti),'LV_Type'));
            text(ax, 5.05, yX+0.86, safeName(T(ti)), 'FontWeight','bold','Color',cXfr,'HorizontalAlignment','left');
            text(ax, 5.05, yX+0.62, conn, 'Color',[0.3 0.3 0.3],'HorizontalAlignment','left');
            text(ax, 5.05, yX+0.32, sprintf('W1: %.1f A   W2: %.1f A', Iw1, Iw2), ...
                 'Color',cXfr,'HorizontalAlignment','left','FontSize',9);

            % Draw ground symbol(s) where applicable & flow arrow
            % Rule: if winding type is wye|auto → it has a path to ground
            xg = 3.9; dx = 0.55; % place ground(s) to left of symbol
            drewAny = false;

            if isGrounded(T(ti),'HV_Type')
                draw_ground(ax, xg, yX+0.40, cGrnd);
                draw_updown_arrow(ax, xg, yX+0.55, signToDown(Iw1), cGrnd); % + => down
                text(ax, xg-0.05, yX+0.75, sprintf('%.1f A', Iw1), ...
                     'HorizontalAlignment','right','Color',cGrnd,'FontSize',9);
                subGroundSum = subGroundSum + Iw1;
                drewAny = true; xg = xg - dx;
            end
            if isGrounded(T(ti),'LV_Type')
                draw_ground(ax, xg, yX-0.10, cGrnd);
                draw_updown_arrow(ax, xg, yX+0.05, signToDown(Iw2), cGrnd);
                text(ax, xg-0.05, yX+0.25, sprintf('%.1f A', Iw2), ...
                     'HorizontalAlignment','right','Color',cGrnd,'FontSize',9);
                subGroundSum = subGroundSum + Iw2;
                drewAny = true;
            end

            if ~drewAny
                % No grounded winding → gray hint (delta–delta, etc.)
                text(ax, 3.9, yX, '(no grounded winding)', 'Color',[0.55 0.55 0.55], ...
                     'HorizontalAlignment','right','FontAngle','italic','FontSize',9);
            end

            yX = yX - 1.10;
        end
    end

    % ===================== Substation ground total ============================
    % Vertical drop from bus to site ground + symbol + label
    plot(ax,[5 5],[6.5 5.6],'k-','LineWidth',1.5);
    draw_ground(ax, 5, 5.35, cGrnd);

    % Sum = Σ lines toward node (inSum) + Σ lines away (outSum) should balance Σ grounded windings
    % But you asked to show *what's flowing to ground* at the sub: we take the grounded-winding sum.
    text(ax, 5.2, 5.75, sprintf('To ground (sub): %.1f A', subGroundSum), ...
         'Color',cGrnd,'HorizontalAlignment','left','FontWeight','bold');

    % Optional quick balance check (can comment out)
    residual = (inSum + outSum) - subGroundSum; % should be ~0 if everything aligns
    text(ax, 5.0, 4.65, sprintf('KCL residual ≈ %.2f A', residual), ...
         'HorizontalAlignment','center','Color',[0.35 0.35 0.35]);

    hold(ax,'off');

    %---------------------- helpers (kept minimal) ---------------------------
    function nm = safeName(S0)
        if isfield(S0,'Name') && ~isempty(S0.Name), nm = S0.Name; else, nm = '?'; end
    end
    function tf = isGrounded(T0, fld)
        tf = isfield(T0,fld) && ~isempty(T0.(fld)) && any(strcmpi(T0.(fld), {'wye','auto'}));
    end
    function s = lowerOrQ(S0,fld)
        if isfield(S0,fld) && ~isempty(S0.(fld)), s = lower(string(S0.(fld))); else, s = "?"; end
    end
    function x = getG(G0, ti, w, t)
        x = NaN;
        if isfield(G0,'Trans') ...
           && size(G0.Trans,1) >= ti && size(G0.Trans,2) >= w && size(G0.Trans,3) >= t
            x = G0.Trans(ti,w,t);
        end
    end
    function d = signToDown(Iw) % + means to ground → point down; − means from ground → up
        if ~isfinite(Iw) || Iw==0, d = 0; elseif Iw>0, d = +1; else, d = -1; end;
    end
    
end

% ======= small drawing utilities =========================================
function draw_transformer_symbol(ax, x, y, col)
% Two coils, centered (x,y), about 0.8×0.8
    r = 0.18; dx = 0.22; th = linspace(pi*0.15, pi*1.85, 70);
    plot(ax, x-dx + r*cos(th), y + r*sin(th), 'Color',col,'LineWidth',1.5);
    plot(ax, x+dx + r*cos(th), y + r*sin(th), 'Color',col,'LineWidth',1.5);
end

function draw_ground(ax, x, y, col)
% Ground: three bars decreasing in width
    lw = 1.2;
    plot(ax,[x x],[y y-0.16],'Color',col,'LineWidth',lw);
    plot(ax,[x-0.18 x+0.18],[y-0.18 y-0.18],'Color',col,'LineWidth',lw);
    plot(ax,[x-0.12 x+0.12],[y-0.26 y-0.26],'Color',col,'LineWidth',lw);
    plot(ax,[x-0.06 x+0.06],[y-0.34 y-0.34],'Color',col,'LineWidth',lw);
end

function draw_arrow(ax, x1, y1, x2, y2, col)
% Short line with triangular head pointing (x1,y1)->(x2,y2)
    plot(ax,[x1 x2],[y1 y2],'Color',col,'LineWidth',2);
    v = [x2-x1, y2-y1]; L = hypot(v(1),v(2)); if L==0, return; end
    v = v/L; n = [-v(2), v(1)];
    ah = 0.18; aw = 0.12;  % head length/width (axis units)
    p3 = [x2 y2]; p1 = p3 - ah*v + aw*n; p2 = p3 - ah*v - aw*n;
    patch('Parent',ax,'XData',[p1(1) p3(1) p2(1)],'YData',[p1(2) p3(2) p2(2)], ...
          'FaceColor',col,'EdgeColor','none');
end

function draw_updown_arrow(ax, x, y, dir, col)
% dir = +1 (down), -1 (up), 0 (invisible)
    if dir==0, return; end
    L = 0.22;
    if dir>0
        draw_arrow(ax, x, y, x, y- L, col);    % down
    else
        draw_arrow(ax, x, y- L, x, y, col);    % up
    end
end
